#!/usr/bin/env python3

#
# This file is part of Tedium.
#
# Copyright (C) 2020 Jared Boone <jared@sharebrained.com>
# SPDX-License-Identifier: BSD-3-Clause

from typing import List

from amaranth                       import *
from amaranth.hdl.ast               import Rose
from luna.gateware.platform.core import LUNAPlatform

from luna.usb2                      import USBDevice

from usb_protocol.types             import USBRequestType, USBStandardRequests

from tedium.gateware.usb.isochronous import USBIsochronousInEndpointTedium, USBIsochronousOutEndpointTedium
from tedium.gateware.usb.descriptors_vendor import Descriptors
from tedium.gateware.usb.handler_set_interface import SetInterfaceRequestHandler
from tedium.gateware.usb.microprocessor_handler import FramerMicroprocessorBusVendorRequest
from tedium.gateware.usb.status import USBSignalInEndpointTedium

from tedium.gateware.framer.bit_timing import BitTiming
from tedium.gateware.framer.microprocessor import MicroprocessorInterface
from tedium.gateware.framer.paged_fifo import PagedAsyncFIFO, PagedFIFOWriteInterface
from tedium.gateware.framer.report import Report
from tedium.gateware.framer.rx_block import RxBlock
from tedium.gateware.framer.rx_fifo_to_usb import RxFIFOToUSBInAdapter
from tedium.gateware.framer.rx_framer_to_fifo import RxFramerToFIFOAdapter
from tedium.gateware.framer.system_timing import SystemTiming
from tedium.gateware.framer.tx_block import TxBlock
from tedium.gateware.framer.tx_fifo_to_framer import TxFIFOToFramerAdapter
from tedium.gateware.framer.tx_usb_to_fifo import TxUSBOutToFIFOAdapter

CHANNELS = 8
TIMESLOTS_PER_CHANNEL = 24
TIMESLOTS_PER_FRAME = TIMESLOTS_PER_CHANNEL * CHANNELS

class RxFrameReport(Report):
    """
    Report from the framer side of the system.
    """
    LAYOUT = [
        ('frame_count', 32),
    ]

    def __init__(self):
        super().__init__(self.LAYOUT, name=self.__class__.__name__)

class RxUSBReport(Report):
    """
    Report from the USB side of the system.
    FIFO levels should be more up-to-date here, as they're
    captured just before transmission.
    """
    LAYOUT = [
        ('sof_count',               32),
        ('fifo_rx_level',            8),
        ('fifo_tx_level',            8),
        ('fifo_rx_underflow_count', 16),
        ('fifo_tx_overflow_count',  16),
        ('sequence_count',           8),
    ]

    def __init__(self):
        super().__init__(self.LAYOUT, name=self.__class__.__name__)

class TxUSBReport(Report):
    """
    """
    LAYOUT = [
        ('frame_count', 32),
    ]

    def __init__(self):
        super().__init__(self.LAYOUT, name=self.__class__.__name__)

class TxFrameReport(Report):
    """
    """
    LAYOUT = [
        ('frame_count', 32),
    ]

    def __init__(self):
        super().__init__(self.LAYOUT, name=self.__class__.__name__)

def usb_framer(platform, m: Module, usb: USBDevice, ep_out: USBIsochronousOutEndpointTedium, ep_in: USBIsochronousInEndpointTedium, output_enable: Signal):
    """
    Loop USB OUT data to USB IN through FIFOs connected via a timeslot interface.
    """

    rx_fifo_depth = 8
    tx_fifo_depth = 32

    rx_frame_report = RxFrameReport()
    rx_frame_record_size = TIMESLOTS_PER_FRAME + rx_frame_report.length_bytes()

    tx_frame_report = TxFrameReport()
    tx_frame_record_size = TIMESLOTS_PER_FRAME + tx_frame_report.length_bytes()

    rx_usb_report = RxUSBReport()
    tx_usb_report = TxUSBReport()

    sclk = Signal()
    sclk_index = Signal(range(CHANNELS))
    m.d.comb += sclk_index.eq(0)

    serclk = Signal()

    bit_timing = m.submodules.bit_timing = BitTiming()
    m.d.comb += bit_timing.serclk.eq(serclk)

    system_timing = m.submodules.system_timing = SystemTiming(TIMESLOTS_PER_CHANNEL)
    m.d.comb += system_timing.bit_end_strobe.eq(bit_timing.iface.bit_end_strobe)

    rx_phys = [platform.request("rx", n) for n in range(CHANNELS)]
    rx_blocks: List[RxBlock] = []
    for i, phy in enumerate(rx_phys):
        rx_block = RxBlock(phy, system_timing.iface)
        rx_blocks.append(rx_block)
        m.submodules[f"rx_block{i}"] = rx_block

        m.d.comb += [
            rx_block.serclk.eq(serclk),
            rx_block.output_enable.eq(output_enable),
        ]
    rx_timeslots = [rx_block.timeslot for rx_block in rx_blocks]

    rx_sclks = Cat([block.sclk for block in rx_blocks])
    m.d.comb += sclk.eq(rx_sclks.bit_select(sclk_index, 1))
    m.d.comb += serclk.eq(sclk)

    rx_fifo        = m.submodules.rx_fifo        = PagedAsyncFIFO(rx_frame_record_size, rx_fifo_depth, w_domain="sync", r_domain="usb")
    rx_framer_fifo = m.submodules.rx_framer_fifo = RxFramerToFIFOAdapter(rx_fifo.writer, rx_timeslots, system_timing.iface, rx_frame_report)
    rx_fifo_usb    = m.submodules.rx_fifo_usb    = RxFIFOToUSBInAdapter(rx_fifo.reader, ep_in, rx_usb_report)
    m.d.comb += rx_fifo_usb.start_of_frame.eq(usb.sof_detected)

    tx_phys = [platform.request("tx", n) for n in range(CHANNELS)]
    tx_blocks: List[TxBlock] = []
    for i, phy in enumerate(tx_phys):
        tx_block = TxBlock(phy, system_timing.iface)
        tx_blocks.append(tx_block)
        m.submodules[f"tx_block{i}"] = tx_block

        m.d.comb += [
            tx_block.serclk.eq(serclk),
            tx_block.output_enable.eq(output_enable),
        ]
    tx_timeslots = [tx_block.timeslot for tx_block in tx_blocks]

    tx_fifo        = m.submodules.tx_fifo        = PagedAsyncFIFO(tx_frame_record_size, tx_fifo_depth, w_domain="usb", r_domain="sync")
    tx_fifo_framer = m.submodules.tx_fifo_framer = TxFIFOToFramerAdapter(tx_fifo.reader, tx_timeslots, system_timing.iface, tx_frame_report)
    tx_usb_fifo    = m.submodules.tx_usb_fifo    = TxUSBOutToFIFOAdapter(ep_out, tx_fifo.writer, tx_usb_report)
    m.d.comb += tx_usb_fifo.start_of_frame.eq(usb.sof_detected)

    with m.If(usb.sof_detected):
        m.d.usb += [
            rx_usb_report.sof_count.eq(rx_usb_report.sof_count + 1),
            rx_usb_report.fifo_rx_level.eq(rx_fifo.reader.r_level2),
            rx_usb_report.fifo_tx_level.eq(tx_fifo.writer.w_level2),
            rx_usb_report.sequence_count.eq(rx_usb_report.sequence_count + 1),
        ]
    with m.If(rx_fifo.reader.r_underflow):
        m.d.usb += rx_usb_report.fifo_rx_underflow_count.eq(rx_usb_report.fifo_rx_underflow_count + 1),
    with m.If(tx_fifo.writer.w_overflow):
        m.d.usb += rx_usb_report.fifo_tx_overflow_count.eq(rx_usb_report.fifo_tx_overflow_count + 1),

    with m.If(system_timing.iface.frame_strobe):
        m.d.sync += [
            rx_frame_report.frame_count.eq(rx_frame_report.frame_count + 1),
        ]

class Device(Elaboratable):

    def elaborate(self, platform: LUNAPlatform) -> Module:
        m = Module()

        m.submodules.car = platform.clock_domain_generator()

        ###############################################################
        # FPGA configuration

        program = platform.request("program")
        m.d.comb += program.eq(0)

        ###############################################################
        # USB

        ulpi = platform.request(platform.default_usb_connection)
        m.submodules.usb = usb = USBDevice(bus=ulpi)

        control_ep = usb.add_control_endpoint()
        blacklist_standard_request_handlers = []

        request_handler_set_interface = SetInterfaceRequestHandler()
        control_ep.add_request_handler(request_handler_set_interface)
        blacklist_standard_request_handlers += [
            lambda setup:   (setup.type    ==  USBRequestType.STANDARD)
                          & (setup.request == USBStandardRequests.SET_INTERFACE)
        ]

        d = Descriptors().create_descriptors()
        control_ep.add_standard_request_handlers(d, blacklist=blacklist_standard_request_handlers)

        interface_frame_stream_active = request_handler_set_interface.frame_stream_interface_altsetting == Descriptors.AlternateSetting.Active

        # Connect our device as a high speed device by default.
        m.d.comb += [
            usb.connect          .eq(1),
            usb.full_speed_only  .eq(0),
        ]

        ###############################################################
        # Framer registers interface to USB

        microprocessor_request = DomainRenamer("usb")(FramerMicroprocessorBusVendorRequest())
        control_ep.add_request_handler(microprocessor_request)

        microprocessor_bus = platform.request('microprocessor_bus')
        microprocessor_if = m.submodules.microprocessor_if = DomainRenamer("usb")(MicroprocessorInterface(bus=microprocessor_bus))

        m.d.comb += [
            microprocessor_if.address.eq(microprocessor_request.address),
            microprocessor_if.data_wr.eq(microprocessor_request.data_wr),
            microprocessor_if.start.eq(microprocessor_request.start),
            microprocessor_if.write.eq(microprocessor_request.write),
            microprocessor_request.data_rd.eq(microprocessor_if.data_rd),
            microprocessor_request.busy.eq(microprocessor_if.busy),
        ]

        ###############################################################
        # Framer interrupt

        # Create an interrupt endpoint which will carry the value of our counter to the host
        # each time our interrupt EP is polled.

        interrupt_ep = USBSignalInEndpointTedium(
            width=32,
            endpoint_number=Descriptors.EndpointNumber.Interrupt,
            endianness="big"
        )
        usb.add_endpoint(interrupt_ep)

        # TODO: SEND SOMETHING USEFUL OVER THE INTERRUPT!        
        m.d.comb += interrupt_ep.signal.eq(0x69696969)

        # NOTE: WOW, WHAT A FOOT-GUN! Using Fell() or Rose(), don't forget
        # to specify your clock domain, or you'll get "sync" by default,
        # which will cause of erratic behavior.

        """
        The way this used to work, typically:

        * Framer's interrupt active edge is detected.
        * `event_pending` set to 1.
        * USB host performs IN on endpoint, polling for "data" (non-zero length means there was an interrupt).
        * When USB IN is over, `event_pending` is set to 0.
        * Host reads some registers by control transfer, eventually causing the flag(s) that asserted the interrupt to clear, and the framer's interrupt signal to deassert.

        However, at some point, we wound up with a stalled host, waiting for an interrupt that never comes.
        I assume this is because the FPGA logic thinks the host is freshly notified of an interrupt, but the host
        thinks it's cleared all interrupts and is waiting for the next notification from the FPGA.

        Now, as a test, we're just generating an IN interrupt response (non-NAK) whenever the framer's INT# is asserted. And sure enough, it's been running for many hours
        now, without a hitch, whereas before, it'd get stuck after a few minutes.

        TODO: There is certainly a better way. Ideally, there'd be a little microcontroller handling the framer's microprocessor interface, catching and interpreting
        interrupts, and sending them to the host in a more high-level form.
        """
        framer_int_usb = Signal()
        m.d.usb += framer_int_usb.eq(microprocessor_bus.int)
        m.d.comb += interrupt_ep.event_pending.eq(framer_int_usb)

        ###############################################################
        # Framer miscellaneous pin config

        framer_outputs_enable = Signal()
        m.d.comb += framer_outputs_enable.eq(microprocessor_request.framer_if_enable)

        txon = platform.request("txon")
        extosc8k = platform.request("extosc8k")
        rxtsel = platform.request("rxtsel")

        m.d.comb += [
            txon.eq(framer_outputs_enable),		# 0x0FN2.TXON_n must still be set to 1 to enable driver.
            extosc8k.eq(0),
            rxtsel.eq(1),
        ]

        ###############################################################
        # USB isochronous endpoints for transfer of timeslot data.

        usb_iso_in_ep = USBIsochronousInEndpointTedium(
            endpoint_number=Descriptors.EndpointNumber.FrameStream,
            max_packet_size=Descriptors.FRAME_BYTES_MAX,
        )
        usb.add_endpoint(usb_iso_in_ep)

        usb_iso_out_ep = USBIsochronousOutEndpointTedium(
            endpoint_number=Descriptors.EndpointNumber.FrameStream,
            max_packet_size=Descriptors.FRAME_BYTES_MAX,
        )
        usb.add_endpoint(usb_iso_out_ep)

        usb_framer(platform, m, usb, usb_iso_out_ep, usb_iso_in_ep, framer_outputs_enable)

        ###############################################################
        # Test Points

        # NOTE: LIU loop-back modes LIUCCR2.LOOP2_n:
        # "Dual" (0b100) and "Digital" (0b111) will go to wacky RXSERCLK
        # rates (72MHz?!) if clock source select CSR.CSS is set to "Loop
        # Timing Mode".

        tp9  = platform.request("tp9" ) # FPGA P2, left of two center pads near SPI flash
        tp7  = platform.request("tp7" ) # FPGA N1, right of two center pads near SPI flash
        tp10 = platform.request("tp10") # FPGA C4, right of a ground pad near framer

        m.d.comb += [
            tp9.eq( 0),
            tp7.eq( 0),
            tp10.eq(0),
        ]

        return m

if __name__ == "__main__":
    USE_LUNA = False

    if USE_LUNA:
        from luna import top_level_cli

        design = Device()
        device = top_level_cli(design, cli_soc=design.soc)
    else:
        from tedium.gateware.xplatform.tedium import TediumX8Platform

        platform = TediumX8Platform()
        design = Device()
        design.soc.build(build_dir="build/soc", do_init=True)
        platform.build(design, build_dir="build/design", do_program=True)
