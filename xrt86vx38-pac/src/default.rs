use crate::device::{Result, Xyz};


struct Row(u16, [u8; 16]);

const NOOP: u8 = 0x69;
const READ: u8 = 0x42;
const IGNR: u8 = 0x23;

const DEFAULTS_XXXX: [Row; 1] = [
    // At power up, I read: 0fe0: 00 00 00 00 00 00 00 ff ff 01 00 00 ff 00 00 00
    Row(0xfe0, [0x00, 0x00, 0x00, NOOP, 0x00, NOOP, NOOP, NOOP, NOOP, 0x01, READ, NOOP, NOOP, NOOP, NOOP, NOOP]),
];

const DEFAULTS_NXXX: [Row; 30] = [
    Row(0x100, [0x11, 0x00, NOOP, NOOP, NOOP, NOOP, NOOP, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, READ, READ, READ]),
    Row(0x110, [READ, IGNR, 0x04, 0x00, READ, READ, 0x05, 0x04, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x40, 0x00, NOOP]),   // I think writing TDLBCR1 and/or RDLBCR1 might cause a spurious TxSOT interrupt?
    Row(0x120, [0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0x00, 0x80, 0x00, 0xaa, 0xaa, 0x00, 0xaa, 0xaa]),
    Row(0x130, [0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, NOOP, NOOP, NOOP, IGNR, IGNR, IGNR, IGNR, IGNR]),
    Row(0x140, [0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0x00]),
    Row(0x150, [0xaa, 0xaa, NOOP, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, IGNR]),
    Row(0x160, [IGNR, IGNR, IGNR, 0x00, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    Row(0x170, [0x00, IGNR, 0x00, 0x00, 0x00, 0x00, 0x01, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x180, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x190, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x1a0, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x1b0, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x1c0, [IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    // Row(0x1d0, [IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    // Row(0x1e0, [IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    // Row(0x1f0, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    Row(0x300, [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]),
    Row(0x310, [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]),
    Row(0x320, [0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17]),
    Row(0x330, [0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17]),
    Row(0x340, [0x01, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0]),
    Row(0x350, [0xb3, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0]),
    Row(0x360, [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]),
    Row(0x370, [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]),
    Row(0x380, [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    Row(0x390, [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    Row(0x3a0, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    Row(0x3b0, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    Row(0x3c0, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    Row(0x3d0, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    // Row(0x3e0, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x3f0, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0x500, [IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    // Row(0x510, [IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR, IGNR]),
    Row(0x900, [READ, READ, READ, READ, READ, READ, READ, NOOP, NOOP, READ, READ, READ, READ, READ, READ, READ]),
    Row(0x910, [READ, READ, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, READ, NOOP, NOOP, NOOP]),
    Row(0x920, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, READ, NOOP, NOOP, NOOP]),
    Row(0xb00, [IGNR, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, NOOP, NOOP, READ, 0x00]),
    Row(0xb10, [READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00]),
    Row(0xb20, [READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, READ, 0x00, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0xb30, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    Row(0xb40, [READ, 0x00, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0xb50, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    // Row(0xb60, [NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
    Row(0xb70, [READ, 0x00, NOOP, NOOP, READ, 0x00, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP]),
];

const DEFAULTS_XXNX: [Row; 1] = [
    Row(0xf00, [0x00, 0x00, 0x00, 0x00, 0x00, IGNR, READ, IGNR, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
];

impl Row {
    fn write<D: Xyz>(&self, base_address: u16, device: &D) -> Result<()> {
        for (n, &value) in self.1.iter().enumerate() {
            let address = base_address + n as u16;
            match value {
                NOOP | IGNR => {},
                READ => {
                    device.register_read(address)?;
                },
                _ => {
                    device.register_write(address, value)?
                }
            }
        }
        Ok(())
    }
}

/// Apply XRT86V38 register defaults to a device through its "uP" interface.
/// 
pub fn framer_defaults<D: Xyz>(device: &D) -> Result<()> {
    // TODO: Disable FPGA outputs to framer when we change configuration.
	// device.framer_interface_control(false)?;

    // Notes:
    // 
    // On power-up:
    // 0xN112 RIFR[2] = 1 but datasheet says 0. Doesn't seem to matter unless another bit (defaut 0) is set to 1.
    // 0xN340 TSCR0[7:4] (transmit signaling bits A-D) = 0b0000, but datasheet says "N".
    // 0x4102 GPIOCR1[7:4] = 0b1111 (outputs), but datasheet says 0b0000 (inputs). The docs for 0x0102 GPIOCR0 are correct though.
    
    for row in DEFAULTS_XXXX {
        let base_address = row.0;
        row.write(base_address, device)?;
    }

    for row in DEFAULTS_NXXX {
        for c in 0..8 {
            let base_address = (c << 12) | row.0;
            row.write(base_address, device)?;
        }
    }

    for row in DEFAULTS_XXNX {
        for c in 0..8 {
            let base_address = (c << 4) | row.0;
            row.write(base_address, device)?;
        }
    }

    Ok(())
}
