#!/usr/bin/env python3

#
# This file is part of Tedium.
#
# Copyright (C) 2020 Jared Boone <jared@sharebrained.com>
# SPDX-License-Identifier: BSD-3-Clause

import sys
import time

import usb.core

from gateware.common import *

def property_global_ro(address):
	return property(lambda device: device.read(address))

def property_global_rw(address):
	return property(lambda device: device.read(address), lambda device, value: device.write(address, value))

class Device:
	def __init__(self):
		self._handle = usb.core.find(idVendor=VENDOR_ID, idProduct=PRODUCT_ID)

		class Spans:
			def __init__(self, device):
				self._device = device

			def __getitem__(self, key):
				if not isinstance(key, int):
					raise TypeError()
				if key < 0 or key > 7:
					raise IndexError()
				return Span(self._device, key)

		self.spans = Spans(self)

	def framer_interface_control(self, enable: bool):
		print('Framer interface: {}'.format(enable))
		request_type = usb.ENDPOINT_OUT | usb.RECIP_DEVICE | usb.TYPE_VENDOR
		value = int(enable)
		index = 0
		length = 0
		return self._handle.ctrl_transfer(request_type, REQUEST_FRAMER_IF_CONTROL, value, index, length)

	def read(self, address):
		request_type = usb.ENDPOINT_IN | usb.RECIP_DEVICE | usb.TYPE_VENDOR
		value = 0
		index = address
		length = 1
		result = self._handle.ctrl_transfer(request_type, REQUEST_REGISTER_READ, value, index, length)[0]
		# print('{:04x} == {:02x}'.format(address, result))
		return result

	def read_u16(self, address_h):
		address_l = address_h + 1
		h = self.read(address_h)
		l = self.read(address_l)
		return (h << 16) | l

	def write(self, address, data):
		print('{:04x} <- {:02x}'.format(address, data))
		request_type = usb.ENDPOINT_OUT | usb.RECIP_DEVICE | usb.TYPE_VENDOR
		value = data
		index = address
		length = 0
		return self._handle.ctrl_transfer(request_type, REQUEST_REGISTER_WRITE, value, index, length)

	devid = property_global_ro(0x01fe)
	revid = property_global_ro(0x01ff)

	# @property
	# def liugcr(self):
	# 	class LIUGCRs:
	# 		def __init__(self, device):
	# 			self.device = device

	# 		def __getitem__(self, key):
	# 			if not isinstance(key, int):
	# 				raise TypeError()
	# 			if key < 0 or key > 5:
	# 				raise IndexError()
	# 			return self.device.read(0x0fe0 + key)

	# 		def __setitem__(self, key, value):
	# 			if not isinstance(key, int):
	# 				raise TypeError()
	# 			if key < 0 or key > 5:
	# 				raise IndexError()
	# 			self.device.write(0x0fe0 + key, value)

	# 	return LIUGCRs(self)

	liugcr0 = property_global_rw(0x0fe0)
	liugcr1 = property_global_rw(0x0fe1)
	liugcr2 = property_global_rw(0x0fe2)
	liugcr3 = property_global_rw(0x0fe4)
	liugcr4 = property_global_rw(0x0fe9)
	liugcr1 = property_global_rw(0x0fea)

def property_framer_ro(address):
	return property(lambda span: span.read_framer(address))

def property_framer_ro_u16(address):
	return property(lambda span: span.read_framer_u16(address))

def property_framer_rw(address):
	return property(lambda span: span.read_framer(address), lambda span, value: span.write_framer(address, value))

def property_liu_ro(address):
	return property(lambda span: span.read_liu(address))

def property_liu_rw(address):
	return property(lambda span: span.read_liu(address), lambda span, value: span.write_liu(address, value))

class Span:
	def __init__(self, device, index):
		self.device = device
		self.index = index

		class Channels:
			def __init__(self, span):
				self._span = span

			# def __len__(self):
			# 	print('__len__')
			# 	return 24

			# def __length_hint__(self):
			# 	print('__length_hint__')
			# 	return 24

			def __getitem__(self, key):
				if not isinstance(key, int):
					raise TypeError()
				if key < 0 or key > 23:
					raise IndexError()
				return Channel(self._span, key)

		self.channels = Channels(self)

	def read_framer(self, address):
		assert(address >= 0x100 and address < 0xf00)
		address |= self.index << 12
		return self.device.read(address)

	def read_framer_u16(self, address):
		assert(address >= 0x100 and address < 0xf00)
		address |= self.index << 12
		return self.device.read_u16(address)

	def write_framer(self, address, value):
		assert(address >= 0x100 and address < 0xf00)
		address |= self.index << 12
		self.device.write(address, value)

	def read_liu(self, address):
		assert(address >= 0xf00 and address < 0xf80)
		address |= self.index << 4
		return self.device.read(address)

	def write_liu(self, address, value):
		assert(address >= 0xf00 and address < 0xf80)
		address |= self.index << 4
		self.device.write(address, value)

	csr      = property_framer_rw    (0x100)
	licr     = property_framer_rw    (0x101)
	fsr      = property_framer_rw    (0x107)
	agr      = property_framer_rw    (0x108)
	smr      = property_framer_rw    (0x109)
	tsdlsr   = property_framer_rw    (0x10a)
	fcr      = property_framer_rw    (0x10b)
	rsdlsr   = property_framer_rw    (0x10c)

	@property
	def rscr(self):
		"""Receive Signaling Change registers (not to be confused with the 'Control' registers)"""
		rscr0 = self.read_framer(0x10d)
		rscr1 = self.read_framer(0x10e)
		rscr2 = self.read_framer(0x10f)
		return (rscr2 << 16) | (rscr1 << 8) | (rscr0 << 0)

	rifr     = property_framer_rw    (0x112)
	dlcr1    = property_framer_rw    (0x113)
	tdlbcr1  = property_framer_rw    (0x114)
	rdlbcr1  = property_framer_rw    (0x115)
	sbcr     = property_framer_rw    (0x116)
	ffolr    = property_framer_rw    (0x117)
	d0wcr    = property_framer_rw    (0x118)
	d1rcr    = property_framer_rw    (0x119)
	icr      = property_framer_rw    (0x11a)
	lapdsr   = property_framer_rw    (0x11b)
	ciagr    = property_framer_rw    (0x11c)
	prcr     = property_framer_rw    (0x11d)
	gccr     = property_framer_rw    (0x11e)
	ticr     = property_framer_rw    (0x120)
	bertcsr0 = property_framer_rw    (0x121)
	ricr     = property_framer_rw    (0x122)
	bertcsr1 = property_framer_rw    (0x123)

	lccr0    = property_framer_rw    (0x124)
	tlcr     = property_framer_rw    (0x125)
	rlacr0   = property_framer_rw    (0x126)
	rldcr0   = property_framer_rw    (0x127)
	rlcds    = property_framer_rw    (0x128)
	dder     = property_framer_rw    (0x129)

	lccr1    = property_framer_rw    (0x12a)
	rlacr1   = property_framer_rw    (0x12b)
	rldcr1   = property_framer_rw    (0x12c)

	lccr2    = property_framer_rw    (0x12d)
	rlacr2   = property_framer_rw    (0x12e)
	rldcr2   = property_framer_rw    (0x12f)

	tlcgs    = property_framer_rw    (0x140)
	lcts     = property_framer_rw    (0x141)
	tsprmcr  = property_framer_rw    (0x142)
	dlcr2    = property_framer_rw    (0x143)

	tdlbcr2  = property_framer_rw    (0x144)
	rdlbcr2  = property_framer_rw    (0x145)

	lccr3    = property_framer_rw    (0x146)
	rlacr3   = property_framer_rw    (0x147)
	rldcr3   = property_framer_rw    (0x148)

	lccr4    = property_framer_rw    (0x149)
	rlacr4   = property_framer_rw    (0x14a)
	rldcr4   = property_framer_rw    (0x14b)

	lccr5    = property_framer_rw    (0x14c)
	rlacr5   = property_framer_rw    (0x14d)
	rldcr5   = property_framer_rw    (0x14e)

	lccr6    = property_framer_rw    (0x14f)
	rlacr6   = property_framer_rw    (0x150)
	rldcr6   = property_framer_rw    (0x151)

	dlcr3    = property_framer_rw    (0x153)

	tdlbcr3  = property_framer_rw    (0x154)
	rdlbcr3  = property_framer_rw    (0x155)

	lccr7    = property_framer_rw    (0x156)
	rlacr7   = property_framer_rw    (0x157)
	rldcr7   = property_framer_rw    (0x158)

	bcr      = property_framer_rw    (0x163)

	boccr    = property_framer_rw    (0x170)
	rfdlr    = property_framer_ro    (0x171)
	rfdlmr1  = property_framer_rw    (0x172)
	rfdlmr2  = property_framer_rw    (0x173)
	rfdlmr3  = property_framer_rw    (0x174)
	tfdlr    = property_framer_rw    (0x175)
	tbcr     = property_framer_rw    (0x176)

	@property
	def rds0mr(self):
		class RDS0MRs:
			ADDRESSES = (0x15f, 0x160, 0x161, 0x162, 0x164, 0x165, 0x166, 0x167, 0x168, 0x169, 0x16a, 0x16b, 0x16c, 0x16d, 0x16e, 0x16f, 0x1c0, 0x1c1, 0x1c2, 0x1c3, 0x1c4, 0x1c5, 0x1c6, 0x1c7)

			def __init__(self, span):
				self.span = span

			def __getitem__(self, key):
				address = self.ADDRESSES[key]
				return self.span.read_framer(address)
		
		return RDS0MRs(self)

	@property
	def tds0mr(self):
		class TDS0MRs:
			ADDRESSES = ()

			def __init__(self, span):
				self.span = span

			def __getitem__(self, key):
				assert(key >= 0 and key < 24)
				return self.span.read_framer(0x1d0 + key)
		
		return TDS0MRs(self)

	# 0x300 - 0x3df: Per-channel PCM/signaling control

	# 0x500 - 0x51f: Receive signaling array

	rlcvc    = property_framer_ro    (0x900)
	rfaec    = property_framer_ro_u16(0x902)
	rsefc    = property_framer_ro    (0x904)
	rsbbec   = property_framer_ro_u16(0x905)
	rsc      = property_framer_ro    (0x909)
	rlfc     = property_framer_ro    (0x90a)
	rcfac    = property_framer_ro    (0x90b)
	lfcsec1  = property_framer_ro    (0x90c)
	pbec     = property_framer_ro_u16(0x90d)
	tsc      = property_framer_ro    (0x90f)
	ezvc     = property_framer_ro_u16(0x910)
	lfcsec2  = property_framer_ro    (0x91c)
	lfcsec3  = property_framer_ro    (0x92c)
	
	bisr     = property_framer_ro    (0xb00)
	bier     = property_framer_rw    (0xb01)
	aeisr    = property_framer_ro    (0xb02)
	aeier    = property_framer_rw    (0xb03)
	fisr     = property_framer_ro    (0xb04)
	fier     = property_framer_rw    (0xb05)
	dlsr1    = property_framer_ro    (0xb06)
	dlier1   = property_framer_rw    (0xb07)
	sbisr    = property_framer_ro    (0xb08)
	sbier    = property_framer_rw    (0xb09)
	rlcisr0  = property_framer_ro    (0xb0a)
	rlcier0  = property_framer_rw    (0xb0b)
	exzsr    = property_framer_ro    (0xb0e)
	exzer    = property_framer_rw    (0xb0f)
	ss7sr1   = property_framer_ro    (0xb10)
	ss7er1   = property_framer_rw    (0xb11)
	rlcisr   = property_framer_ro    (0xb12)
	rlcier   = property_framer_rw    (0xb13)
	rlcisr1  = property_framer_ro    (0xb14)
	rlcier1  = property_framer_rw    (0xb15)
	dlsr2    = property_framer_ro    (0xb16)
	dlier2   = property_framer_rw    (0xb17)
	ss7sr2   = property_framer_ro    (0xb18)
	ss7er2   = property_framer_rw    (0xb19)
	rlcisr2  = property_framer_ro    (0xb1a)
	rlcier2  = property_framer_rw    (0xb1b)
	rlcisr3  = property_framer_ro    (0xb1c)
	rlcier3  = property_framer_rw    (0xb1d)
	rlcisr4  = property_framer_ro    (0xb1e)
	rlcier4  = property_framer_rw    (0xb1f)
	rlcisr5  = property_framer_ro    (0xb20)
	rlcier5  = property_framer_rw    (0xb21)
	rlcisr6  = property_framer_ro    (0xb22)
	rlcier6  = property_framer_rw    (0xb23)
	rlcisr7  = property_framer_ro    (0xb24)
	rlcier7  = property_framer_rw    (0xb25)
	dlsr3    = property_framer_ro    (0xb26)
	dlier3   = property_framer_rw    (0xb27)
	ss7sr3   = property_framer_ro    (0xb28)
	ss7er3   = property_framer_rw    (0xb29)
	ciasr    = property_framer_ro    (0xb40)
	ciaier   = property_framer_rw    (0xb41)
	bocisr   = property_framer_ro    (0xb70)
	bocier   = property_framer_rw    (0xb71)
	bocuisr  = property_framer_ro    (0xb74)
	bocuier  = property_framer_rw    (0xb75)

	# @property
	# def rlcisr(self):
	# 	class RLCISRs:
	# 		ADDRESSES = (0xb0a, 0xb14, 0xb1a, 0xb1c, 0xb1e, 0xb20, 0xb22, 0xb24)

	# 		def __init__(self, span):
	# 			self.span = span

	# 		def __getitem__(self, key):
	# 			address = self.ADDRESSES[key]
	# 			return self.span.read_framer(address)
		
	# 	return RLCISRs(self)
	
	liuccr0  = property_liu_rw(0xf00)
	liuccr1  = property_liu_rw(0xf01)
	liuccr2  = property_liu_rw(0xf02)
	liuccr3  = property_liu_rw(0xf03)
	liuccr4  = property_liu_rw(0xf04)
	liuccsr  = property_liu_ro(0xf05)
	liuccisr = property_liu_ro(0xf06)
	liuccccr = property_liu_ro(0xf07)

	liuccar1 = property_liu_rw(0xf08)
	liuccar2 = property_liu_rw(0xf09)
	liuccar3 = property_liu_rw(0xf0a)
	liuccar4 = property_liu_rw(0xf0b)
	liuccar5 = property_liu_rw(0xf0c)
	liuccar6 = property_liu_rw(0xf0d)
	liuccar7 = property_liu_rw(0xf0e)
	liuccar8 = property_liu_rw(0xf0f)

class Channel:
	def __init__(self, span, index):
		self.span = span
		self.index = index

	@property
	def tccr(self):
		return self.span.read_framer(0x300 + self.index)

	@tccr.setter
	def tccr(self, value):
		self.span.write_framer(0x300 + self.index, value)
	
	@property
	def tucr(self):
		return self.span.read_framer(0x320 + self.index)

	@tucr.setter
	def tucr(self, value):
		self.span.write_framer(0x320 + self.index, value)
	
	@property
	def tscr(self):
		return self.span.read_framer(0x340 + self.index)

	@tscr.setter
	def tscr(self, value):
		self.span.write_framer(0x340 + self.index, value)
	
	@property
	def rccr(self):
		return self.span.read_framer(0x360 + self.index)

	@rccr.setter
	def rccr(self, value):
		self.span.write_framer(0x360 + self.index, value)
	
	@property
	def rucr(self):
		return self.span.read_framer(0x380 + self.index)

	@rucr.setter
	def rucr(self, value):
		self.span.write_framer(0x380 + self.index, value)
	
	@property
	def rscr(self):
		return self.span.read_framer(0x3a0 + self.index)

	@rscr.setter
	def rscr(self, value):
		self.span.write_framer(0x3a0 + self.index, value)
	
	@property
	def rssr(self):
		return self.span.read_framer(0x3c0 + self.index)

	@rssr.setter
	def rssr(self, value):
		self.span.write_framer(0x3c0 + self.index, value)
	
	@property
	def rsar(self):
		return self.span.read_framer(0x500 + self.index)

def make_csr(d):
	CLOCK_SOURCE_SELECTION_OPTIONS = {
		'Loop': 0b00,
		'External': 0b01,
		'Internal': 0b10,
	}

	return (d['lcv_insert'] << 7) \
		 | (d['set_t1_mode'] << 6) \
		 | (d['sync_all_tx_to_8khz'] << 5) \
		 | (d['clock_loss_detect'] << 4) \
		 | (CLOCK_SOURCE_SELECTION_OPTIONS[d['clock_source_selection']] << 0)

def make_licr(d):
	FRAMER_LOOPBACK_OPTIONS = {
		None: 0b00,
		'Framer Local': 0b01,
		'Framer Remote': 0b10,
		'Framer Payload': 0b11,
	}
	ENCODE_OPTIONS = {
		'B8ZS/HDB3': 0,
		'AMI': 1,
	}
	DECODE_OPTIONS = {
		'B8ZS/HDB3': 0,
		'AMI': 1,
	}

	return (d['force_los'] << 7) \
		 | FRAMER_LOOPBACK_OPTIONS[d['framer_loopback']] << 4 \
		 | ENCODE_OPTIONS[d['encode']] << 1 \
		 | DECODE_OPTIONS[d['decode']] << 0

def make_fsr(d):
	return (d['signaling_update_on_sf'] << 7) \
		 | (d['force_crc_errors']       << 6) \
		 | (d['j1_mode']                << 5) \
		 | (d['oneonly']                << 4) \
		 | (d['fastsync']               << 3) \
		 | (d['fsi']                    << 0)

def make_sbcr(d):
	SB_ENB_OPTIONS = {
		'Bypass': 0b00,
		'Slip': 0b01,
		'FIFO': 0b10,
	}

	return (d['txsb_isfifo'] << 7) \
		 | (d['sb_forcesf'] << 4) \
		 | (d['sb_sfenb'] << 3) \
		 | (d['sb_sdir'] << 2) \
		 | (SB_ENB_OPTIONS[d['sb_enb']] << 0)

def make_ticr(d):
	TX_I_MODE_OPTIONS = {
		'1.544Mbit/s base rate'       : (0, 0b00),
		'2.048Mbit/s high-speed MVIP' : (0, 0b01),
		'4.096Mbit/s high-speed'      : (0, 0b10),
		'8.192Mbit/s high-speed'      : (0, 0b11),
		'Bit-multiplexed at 12.352MHz': (1, 0b00),
		'HMVIP high-speed multiplexed': (1, 0b10),
		'H.100 high-speed multiplexed': (1, 0b11),
	}

	return (d['tx_sync_fr_d'] << 7) \
		 | (d['tx_pl_clk_enb'] << 5) \
		 | (d['tx_fr_1544'] << 4) \
		 | (d['tx_i_clk_inv'] << 3) \
		 | (TX_I_MODE_OPTIONS[d['tx_i_mode']][0] << 2) \
		 | (TX_I_MODE_OPTIONS[d['tx_i_mode']][1] << 0)

def make_ricr(d):
	RX_I_MODE_OPTIONS = {
		'1.544Mbit/s base rate'       : (0, 0b00),
		'2.048Mbit/s high-speed MVIP' : (0, 0b01),
		'4.096Mbit/s high-speed'      : (0, 0b10),
		'8.192Mbit/s high-speed'      : (0, 0b11),
		'Bit-multiplexed at 12.352MHz': (1, 0b00),
		'HMVIP high-speed multiplexed': (1, 0b10),
		'H.100 high-speed multiplexed': (1, 0b11),
	}

	return (d['rx_sync_fr_d'] << 7) \
		 | (d['rx_pl_clk_enb'] << 5) \
		 | (d['rx_fr_1544'] << 4) \
		 | (d['rx_i_clk_inv'] << 3) \
		 | (RX_I_MODE_OPTIONS[d['rx_i_mode']][0] << 2) \
		 | (RX_I_MODE_OPTIONS[d['rx_i_mode']][1] << 0)

def make_tccr(d):
	LAPDCNTL_OPTIONS = {
		'LAPD 1': 0b00,
		'LAPD 2': 0b01,
		'TxDE': 0b10,
		'LAPD 3': 0b11,
	}

	TXZERO_OPTIONS = {
		None: 0b00,
		'AT&T bit 7 stuffing': 0b01,
		'GTE': 0b10,
		'DDS': 0b11,
	}

	TXCOND_OPTIONS = {
		None: 0x0,
		'all inverted': 0x1,
		'even inverted': 0x2,
		'odd inverted': 0x3,
		'TUCR': 0x4,
		'BUSY': 0x5,
		'VACANT': 0x6,
		'BUSY w/timeslot': 0x7,
		'MOOF': 0x8,
		'A-law digital milliwatt': 0x9,
		'u-Law digital milliwatt': 0xa,
		'MSB inverted': 0xb,
		'!MSB inverted': 0xc,
		'PRBS/QRTS': 0xd,
		'D/E timeslot': 0xf,
	}

	return (LAPDCNTL_OPTIONS[d['LAPDcntl']] << 6) \
		 | (TXZERO_OPTIONS[  d['TxZERO'  ]] << 4) \
		 | (TXCOND_OPTIONS[  d['TxCond'  ]] << 0)

def make_tscr(d):
	TXSIGSRC_OPTIONS = {
		'TxSER': 0b00,
		'TSCR': 0b01,
		'TxSIG': 0b10,	# Also requires TICR.TxFr1544=1
	}

	return (d['A (x)']   << 7) \
		 | (d['B (x)']   << 6) \
		 | (d['C (x)']   << 5) \
		 | (d['D (x)']   << 4) \
		 | (d['Rob_Enb'] << 2) \
		 | (TXSIGSRC_OPTIONS[d['TxSIGSRC']] << 0)

def make_rscr(d):
	RXSIGC_OPTIONS = {
		'All Ones': 0b00,
		'ABCD': 0b01,
		'AB': 0b10,
		'A': 0b11,
	}
	RXSIGE_OPTIONS = {
		None: 0b00,
		'ABCD': 0b01,
		'AB': 0b10,
		'A': 0b11,
	}

	return (d['SIGC_ENB'] << 6) \
		 | (d['OH_ENB']   << 5) \
		 | (d['DEB_ENB']  << 4) \
		 | (RXSIGC_OPTIONS[d['RxSIGC']] << 2) \
		 | (RXSIGE_OPTIONS[d['RxSIGE']] << 0)

def make_liuccr0(d):
	QRSS_PRBS_OPTIONS = {
		'QRSS': 0,
		'PRBS': 1,
	}
	PRBS_RX_TX_OPTIONS = {
		'PRBS -> TTIP/TRING': 0,
		'PRBS -> RPOS/RCLK':  1,
	}
	EQC_OPTIONS = {
		('T1 long haul',  36.0,     0.0, 100, 'tp'  ): 0x00,
		('T1 long haul',  36.0,    -7.5, 100, 'tp'  ): 0x01,
		('T1 long haul',  36.0,   -15.0, 100, 'tp'  ): 0x02,
		('T1 long haul',  36.0,   -22.5, 100, 'tp'  ): 0x03,
		('T1 long haul',  36.0,     0.0, 100, 'tp'  ): 0x04,
		('T1 long haul',  36.0,    -7.5, 100, 'tp'  ): 0x05,
		('T1 long haul',  36.0,   -15.0, 100, 'tp'  ): 0x06,
		('T1 long haul',  36.0,   -22.5, 100, 'tp'  ): 0x07,
		('T1 short haul', 15.0,     0.6, 100, 'tp'  ): 0x08,
		('T1 short haul', 15.0,     1.2, 100, 'tp'  ): 0x09,
		('T1 short haul', 15.0,     1.8, 100, 'tp'  ): 0x0a,
		('T1 short haul', 15.0,     2.4, 100, 'tp'  ): 0x0b,
		('T1 short haul', 15.0,     3.0, 100, 'tp'  ): 0x0c,
		('T1 short haul', 15.0,    None, 100, 'tp'  ): 0x0d,
		('T1 gain mode',  29.0,     0.6, 100, 'tp'  ): 0x0e,
		('T1 gain mode',  29.0,     1.2, 100, 'tp'  ): 0x0f,
		('T1 gain mode',  29.0,     1.8, 100, 'tp'  ): 0x10,
		('T1 gain mode',  29.0,     2.4, 100, 'tp'  ): 0x11,
		('T1 gain mode',  29.0,     3.0, 100, 'tp'  ): 0x12,
		('T1 gain mode',  29.0,    None, 100, 'tp'  ): 0x13,
		('T1 gain mode',  29.0,     0.0, 100, 'tp'  ): 0x14,
		('T1 gain mode',  29.0,    -7.5, 100, 'tp'  ): 0x15,
		('T1 gain mode',  29.0,   -15.0, 100, 'tp'  ): 0x16,
		('T1 gain mode',  29.0,   -22.5, 100, 'tp'  ): 0x17,
		('E1 long haul',  36.0, 'G.703',  75, 'coax'): 0x18,
		('E1 long haul',  36.0, 'G.703', 120, 'tp'  ): 0x19,
		('E1 long haul',  45.0, 'G.703',  75, 'coax'): 0x1a,
		('E1 long haul',  45.0, 'G.703', 120, 'tp'  ): 0x1b,
		('E1 short haul', 15.0, 'G.703',  75, 'coax'): 0x1c,
		('E1 short haul', 15.0, 'G.703', 120, 'tp'  ): 0x1d,
		('E1 gain mode',  29.0, 'G.703',  75, 'coax'): 0x1e,
		('E1 gain mode',  29.0, 'G.703', 120, 'tp'  ): 0x1f,
	}

	return (QRSS_PRBS_OPTIONS[d['qrss_prbs']] << 7) \
		 | (PRBS_RX_TX_OPTIONS[d['prbs_rx_tx']] << 6) \
		 | (d['rxon_n'] << 5) \
		 | (EQC_OPTIONS[d['eqc']] << 0)

def make_liuccr1(d):
	return (d['RXTSEL_n'] << 7) \
		 | (d['TXTSEL_n'] << 6) \
		 | (d['TERSEL'] << 4) \
		 | (d['RxJASEL_n'] << 3) \
		 | (d['TxJASEL_n'] << 2) \
		 | (d['JABW_n'] << 1) \
		 | (d['FIFOS_n'] << 0)

def make_liuccr2(d):
	TXTEST_OPTIONS = {
		None: 0b000,
		'TDQRSS': 0b100,
		'TAOS': 0b101,
		'TLUC': 0b110,
		'TLDC': 0b111,
	}
	LOOP2_OPTIONS = {
		None:      0b000,
		'Dual':    0b100,
		'Analog':  0b101,
		'Remote':  0b110,
		'Digital': 0b111,
	}

	return (d['INVQRSS_n'] << 7) \
		 | (TXTEST_OPTIONS[d['TXTEST']] << 4) \
		 | (d['TXON_n'] << 3) \
		 | (LOOP2_OPTIONS[d['LOOP2_n']] << 0)

def print_register(device, name, address, channel=None):
	value = device.read(address)
	print('{:04x} {:s}={:02x}'.format(address, name, value))

def print_registers(device, address_range):
	line = []
	for address in range(*address_range):
		if len(line) == 0:
			line.append('{:04x}:'.format(address))
		v = device.read(address)
		line.append('{:02x}'.format(v))
		if len(line) == 9:
			line.append('')
		if len(line) == 1 + 1 + 16:
			print(' '.join(line))
			line = []

	if len(line) > 1:
		print(' '.join(line))

def action_dump(device, args):
	dump_all = True

	if dump_all:
		print('All Registers:')
		print_registers(device, (0x0000, 0x10000))
	else:
		print('Device:')
		print_registers(device, (0x01fe, 0x0200))
		print()

		print('Global:')
		print_registers(device, (0x0fe0, 0x0ff0))
		print()

		print('GPIO:')
		print_register(device, 'GPIOCR0', 0x0102)
		print_register(device, 'GPIOCR1', 0x4102)
		print()

		for channel in range(8):
			print('Channel {:d}:'.format(channel))
			
			base = channel << 12
			print_register(device, 'CSR',    base + 0x0100, channel=channel)
			print_register(device, 'LICR',   base + 0x0101, channel=channel)
			print_register(device, 'FSR',    base + 0x0107, channel=channel)
			print_register(device, 'AGR',    base + 0x0108, channel=channel)
			print_register(device, 'SMR',    base + 0x0109, channel=channel)
			print_register(device, 'TSDLSR', base + 0x010a, channel=channel)
			print_register(device, 'FCR',    base + 0x010b, channel=channel)
			print_register(device, 'RSDLSR', base + 0x010c, channel=channel)
			print_register(device, 'RSCR0',  base + 0x010d, channel=channel)
			print_register(device, 'RSCR1',  base + 0x010e, channel=channel)
			print_register(device, 'RSCR2',  base + 0x010f, channel=channel)
			print()

			print_registers(device, (base + 0x0300, base + 0x0318))
			print_registers(device, (base + 0x0320, base + 0x0338))
			print_registers(device, (base + 0x0340, base + 0x0358))
			print_registers(device, (base + 0x0360, base + 0x0378))
			print_registers(device, (base + 0x0380, base + 0x0398))
			print_registers(device, (base + 0x03a0, base + 0x03b8))
			print_registers(device, (base + 0x03c0, base + 0x03d8))

			print()

def action_read(device, args):
	n = int(args.register, 0)
	v = device.read(n)
	print('{:04x} == {:02x}'.format(n, v))

def action_write(device, args):
	n = int(args.register, 0)
	v = int(args.value, 0)
	device.write(n, v)

def init_global(device):

	###################################################################
	# LIUGCR4 (LIU Global Control 4)

	CLKSEL_OPTIONS = {
		'2.048': 0b0000,
		'1.544': 0b0001,
		'4.096': 0b1000,
		'3.088': 0b1001,
		'8.192': 0b1010,
		'6.176': 0b1011,
		'16.384': 0b1100,
		'12.352': 0b1101,
	}
	
	clksel = '16.384'

	liugcr4 = 0
	liugcr4 |= CLKSEL_OPTIONS[clksel] << 0

	# LIU Global Control 4 (LIUGCR4)
	device.liugcr4 = liugcr4

	###################################################################
	# LIUGCR0 (LIU Global Control 0)
	
	single_rail = 0
	ataos = 0
	rclke = 0
	tclke = 0
	datap = 0
	gie = 0
	sreset = 0

	liugcr0 = 0
	liugcr0 |= single_rail << 7
	liugcr0 |= ataos << 6
	liugcr0 |= rclke << 5
	liugcr0 |= tclke << 4
	liugcr0 |= datap << 3
	liugcr0 |= gie << 1
	liugcr0 |= sreset << 0

	# TODO: PRCR (0xN11D) RLOS_OUT_ENB=0 to disable RLOS output pin (which isn't present on the 256-pin package)

	time.sleep(0.1)
	device.liugcr0 = liugcr0 | 1
	time.sleep(1.0)
	device.liugcr0 = liugcr0 | 0
	time.sleep(0.1)

def action_reset(device, args):

	device.framer_interface_control(enable=False)

	# Notes:
	# 
	# On power-up:
	# 0xN112 RIFR[2] = 1 but datasheet says 0. Doesn't seem to matter unless another bit (defaut 0) is set to 1.
	# 0xN340 TSCR0[7:4] (transmit signaling bits A-D) = 0b0000, but datasheet says "N".
	# 0x4102 GPIOCR1[7:4] = 0b1111 (outputs), but datasheet says 0b0000 (inputs). The docs for 0x0102 GPIOCR0 are correct though.

	defaults_channel = (
		('N100', '11 00 __ __ __ __ __ 00  00 00 00 43 00 rr rr rr'),
		('N110', 'rr ro 04 00 00 00 05 04  00 00 00 1c 00 40 00 __'),
		('N120', '00 00 00 00 00 aa aa aa  00 80 00 aa aa 00 aa aa'),
		('N130', '00 00 00 ff ff ff ff ff  __ __ __ ro ro ro ro ro'),
		('N140', '00 06 00 00 00 00 00 aa  aa 00 aa aa 00 aa aa 00'),
		('N150', 'aa aa __ 00 00 00 00 aa  aa __ __ __ __ __ __ ro'),
		('N160', 'ro ro ro 00 ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N170', '00 ro 00 00 00 00 01 __  __ __ __ __ __ __ __ __'),
		('N180', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N190', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N1a0', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N1b0', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N1c0', 'ro ro ro ro ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N1d0', 'ro ro ro ro ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N1e0', 'ro ro ro ro ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N1f0', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N300', '80 80 80 80 80 80 80 80  80 80 80 80 80 80 80 80'),
		('N310', '80 80 80 80 80 80 80 80  80 80 80 80 80 80 80 80'),
		('N320', '17 17 17 17 17 17 17 17  17 17 17 17 17 17 17 17'),
		('N330', '17 17 17 17 17 17 17 17  17 17 17 17 17 17 17 17'),
		('N340', '01 d0 d0 d0 d0 d0 d0 d0  d0 d0 d0 d0 d0 d0 d0 d0'),
		('N350', 'b3 d0 d0 d0 d0 d0 d0 d0  d0 d0 d0 d0 d0 d0 d0 d0'),
		('N360', '80 80 80 80 80 80 80 80  80 80 80 80 80 80 80 80'),
		('N370', '80 80 80 80 80 80 80 80  80 80 80 80 80 80 80 80'),
		('N380', 'ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff'),
		('N390', 'ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff'),
		('N3a0', '00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00'),
		('N3b0', '00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00'),
		('N3c0', '00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00'),
		('N3d0', '00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00'),
		('N3e0', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N3f0', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('N500', 'ro ro ro ro ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N510', 'ro ro ro ro ro ro ro ro  ro ro ro ro ro ro ro ro'),
		('N900', 'rr rr rr rr rr rr rr __  __ rr rr rr rr rr rr rr'),
		('N910', 'rr rr __ __ __ __ __ __  __ __ __ __ rr __ __ __'),
		('N920', '__ __ __ __ __ __ __ __  __ __ __ __ rr __ __ __'),
		('Nb00', 'ro 00 rr 00 rr 00 rr 00  rr 00 rr 00 __ __ rr 00'),
		('Nb10', 'rr 00 rr 00 rr 00 rr 00  rr 00 rr 00 rr 00 rr 00'),
		('Nb20', 'rr 00 rr 00 rr 00 rr 00  rr 00 __ __ __ __ __ __'),
		('Nb30', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('Nb40', 'rr 00 __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('Nb50', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('Nb60', '__ __ __ __ __ __ __ __  __ __ __ __ __ __ __ __'),
		('Nb70', 'rr 00 __ __ rr 00 __ __  __ __ __ __ __ __ __ __'),
		('0fN0', '00 00 00 00 00 ro rr ro  00 00 00 00 00 00 00 00'),
	)

	defaults_global = (
		('0fe0', '00 00 00 __ 00 __ __ __  __ 01 rr __ __ __ __ __'),
		('0102', 'f0'),
		('4102', '00'),
	)

	mode = 'write'

	for channel in range(8):
		for (first_address, values) in defaults_channel:
			first_address = int(first_address.replace('N', str(channel)), 16)
			values = values.split()

			for (address, value) in enumerate(values, start=first_address):
				# print('{:04x} {:s}'.format(address, value))
				if value == '__':
					pass
				elif value == 'ro':
					pass
				elif value == 'rr':
					_discard = device.read(address)
				else:
					# value = value.replace('N', str(channel))
					value = int(value, 16)

					if mode == 'write':
						device.write(address, value)
					elif mode == 'check':
						read_value = device.read(address)
						if read_value != value:
							print('{:04x} {:02x} != {:02x}'.format(address, read_value, value))

	init_global(device)

	csr = make_csr({
		'lcv_insert': 0,
		'set_t1_mode': 1,
		'sync_all_tx_to_8khz': 0,
		'clock_loss_detect': 1,
		'clock_source_selection': 'External',
	})

	# licr = make_licr({
	# 	'force_los': 0,
	# 	'framer_loopback': None,
	# 	'encode': 'B8ZS/HDB3',
	# 	'decode':'B8ZS/HDB3',
	# })

	fsr = make_fsr({
		'signaling_update_on_sf': 1,
		'force_crc_errors': 0,
		'j1_mode': 0,
		'oneonly': 0,
		'fastsync': 0,
		'fsi': 0b000,
	})

	sbcr = make_sbcr({
		'txsb_isfifo': 0,
		'sb_forcesf': 0,
		'sb_sfenb': 0,
		'sb_sdir': 1,		# Regardless, RxSync is an output if slip buffer is bypassed.
		'sb_enb': 'Slip',
	})

	ticr = make_ticr({
		'tx_sync_fr_d': 0,
		'tx_pl_clk_enb': 0,
		'tx_fr_1544': 0,
		'tx_i_clk_inv': 0,
		'tx_i_mode': '1.544Mbit/s base rate',
	})

	ricr = make_ricr({
		'rx_sync_fr_d': 0,
		'rx_pl_clk_enb': 0,
		'rx_fr_1544': 1,	# To obtain recovered receive clock on RxSCLK.
		'rx_i_clk_inv': 0,
		'rx_i_mode': '1.544Mbit/s base rate',
	})

	liuccr0 = make_liuccr0({
		'qrss_prbs': 'QRSS',
		'prbs_rx_tx': 'PRBS -> TTIP/TRING',
		'rxon_n': 1,
		'eqc': ('T1 short haul', 15.0, 0.6, 100, 'tp'),
	})

	liuccr1 = make_liuccr1({
		'RXTSEL_n': 1,	# Internal
		'TXTSEL_n': 1,	# Internal
		'TERSEL': 0b00,	# 100 Ohms,
		'RxJASEL_n': 1,
		'TxJASEL_n': 1,
		'JABW_n': 0,
		'FIFOS_n': 0,
	})

	liuccr2 = make_liuccr2({
		'INVQRSS_n': 0,
		'TXTEST': None,
		'TXON_n': 1,
		'LOOP2_n': None,
	})

	tccr = make_tccr({
		'LAPDcntl': 'TxDE',
		'TxZERO': None,
		'TxCond': None,
	})

	tscr = make_tscr({
		'A (x)': 0,
		'B (x)': 1,
		'C (x)': 0,
		'D (x)': 1,
		'Rob_Enb': 1,
		'TxSIGSRC': 'TSCR',
	})

	rscr = make_rscr({
		'SIGC_ENB': 0,
		'OH_ENB': 0,
		'DEB_ENB': 0,
		'RxSIGC': 'ABCD',
		'RxSIGE': 'ABCD',
	})

	for span in device.spans:
		# Framer
		span.csr = csr
		# span.licr = licr
		span.fsr = fsr
		span.sbcr = sbcr
		span.ticr = ticr
		span.ricr = ricr

		# LIU
		span.liuccr0 = liuccr0
		span.liuccr1 = liuccr1
		span.liuccr2 = liuccr2

		for channel in span.channels:
			channel.tccr = tccr
			channel.tucr = 0x00
			channel.tscr = tscr
			channel.rscr = rscr

	device.framer_interface_control(enable=True)

def action_init(device, args):
	span = device.spans[int(args.span)]

	registers = {}

	###################################################################
	# BERTCSR0

	bert_switch = 0
	unframed_bert = 0

	bertcsr0 = 0
	bertcsr0 |= bert_switch << 3
	bertcsr0 |= unframed_bert << 0

	registers['bertcsr0'] = bertcsr0
	
	###################################################################
	# BERTCSR1: BERT Control & Status, 0xN123

	data_inv = 0
	rx_bert_enb = 0
	tx_bert_enb = 0
	rx_bypass = 0
	tx_bypass = 0

	bertcsr1 = 0
	bertcsr1 |= data_inv << 5
	bertcsr1 |= rx_bert_enb << 3
	bertcsr1 |= tx_bert_enb << 2
	bertcsr1 |= rx_bypass << 1
	bertcsr1 |= tx_bypass << 0

	registers['bertcsr1'] = bertcsr1

	###################################################################
	# BCR (BERT Control Register)

	BERT_OPTIONS = {
		None:                 0b0000,
		'PRBS X20 + X3 + 1':  0b0010,
		'QRSS X20 + X17 + 1': 0b0011,
		'All Ones':           0b0100,
		'All Zeros':          0b0101,
		'3 in 24':            0b0110,
		'1 in 8':             0b0111,
		'55 Octet':           0b1000,
		'Daly':               0b1001,
		'PRBS X20 + X17 + 1': 0b1010,
	}

	bert = None

	bcr = 0
	bcr |= BERT_OPTIONS[bert] << 0

	registers['bcr'] = bcr

	###################################################################

	# Turn off transmitter.
	span.liuccr2 = 0						# LIU Channel Control 2

	span.csr  = registers['csr']			# Clock Select
	span.licr = registers['licr']			# Line Interface Control
	span.fsr  = registers['fsr']			# Framing Select Register
	span.sbcr = registers['sbcr']			# Slip Buffer Control
	span.ticr = registers['ticr']			# Transmit Interface Control
	span.bertcsr0 = registers['bertcsr0']	# BERT Control & Status 0
	span.ricr = registers['ricr']			# Receive Interface Control
	span.bertcsr1 = registers['bertcsr1']	# BERT Control & Status 1
	span.bcr = registers['bcr']				# BERT Control

	span.liuccr0 = registers['liuccr0']
	span.liuccr1 = registers['liuccr1']

	# Turn on transmitter (and whatever loopback mode was selected).
	span.liuccr2 = registers['liuccr2']

	# register_write(device, 0x0fe0, 0b0000_0001)
	# time.sleep(0.1)
	# register_write(device, 0x0fe0, 0b0000_0000)

	# print('\n*** APPLYING FRAMER LOCAL LOOPBACK SETTINGS ***\n')
	# register_write(device, 0x0100, 0x52)
	# register_write(device, 0x0101, 0x10)

	# print('\n*** APPLYING LIU DUAL LOOPBACK SETTINGS ***\n')
	# NOTE: LIU loop-back modes LIUCCR2.LOOP2_n:
	# "Dual" (0b100) and "Digital" (0b111) will go to wacky RXSERCLK
	# rates (72MHz?!) if clock source select CSR.CSS is set to "Loop
	# Timing Mode".
	# register_write(device, 0x0100, 0x52)
	# register_write(device, 0x0f02, 0x0c)

def action_channel(device, args):
	span = device.spans[int(args.span)]

	channels = args.channel
	if channels is None:
		channels_range = range(len(span))
	elif channels < 0 or channels > 23:
		raise RuntimeError('Channel value out of range')
	else:
		channels_range = range(channels, channels)

	if args.rbs:
		bits = int(args.rbs, 2)
		if bits ^ (bits & 0xf) != 0:
			raise RuntimeError('RBS value must be four bits wide or less')

		tscr = make_tscr({
			'A (x)': (bits >> 3) & 1,
			'B (x)': (bits >> 2) & 1,
			'C (x)': (bits >> 1) & 1,
			'D (x)': (bits >> 0) & 1,
			'Rob_Enb': 1,
			'TxSIGSRC': 'TSCR',
		})

		for channel_index in channels_range:
			channel = span.channels[channel_index]
			channel.tscr = tscr

	if args.pcm:
		pcm_v = int(args.pcm, 16)
		if pcm_v < 0 or pcm_v > 255:
			raise RuntimeError('PCM value must be 0-255')

		tccr = make_tccr({
			'LAPDcntl': 'TxDE',
			'TxZERO': None,
			'TxCond': 'TUCR',
		})

		tucr = pcm_v

		for channel_index in channels_range:
			channel = span.channels[channel_index]
			channel.tccr = tccr
			channel.tucr = tucr

def action_monitor(device, args):
	span = device.spans[int(args.span)]

	last_rscr = span.rscr

	while True:
		rscr = span.rscr
		if rscr != span.rscr:
			line = []
			for channel in span.channels:
				rsar = channel.rsar
				status = ['-'] * 4
				if rsar & 1:
					status[3] = 'D'
				if rsar & 2:
					status[2] = 'C'
				if rsar & 4:
					status[1] = 'B'
				if rsar & 8:
					status[0] = 'A'
				line.append(''.join(status))
			print('RxSig: {:s}'.format(' '.join(line)))

		time.sleep(0.1)

def action_status_one(device, args):
	span = device.spans[args.span]

	rifr = span.rifr
	in_frame = (rifr >> 7) & 1
	print('In Frame: {:d}'.format(in_frame))

	sbisr = span.sbisr
	multiframe_lock = (sbisr >> 3) & 1
	print('Multiframe lock: {:d}'.format(multiframe_lock))

	ciasr = span.ciasr
	rxais_ci_state = (ciasr >> 5) & 1
	rxrai_ci_state = (ciasr >> 4) & 1
	print('Rx alarm indication signal - customer installation (AIS-CI): {:d}'.format(rxais_ci_state))
	print('Rx remote alarm indication - customer installation (AIS-CI): {:d}'.format(rxrai_ci_state))

	rlcisr_values = (span.rlcisr0, span.rlcisr1, span.rlcisr2, span.rlcisr3, span.rlcisr4, span.rlcisr5, span.rlcisr6, span.rlcisr7)
	rxastats = [(v >> 3) & 1 for v in rlcisr_values]
	rxdstats = [(v >> 2) & 1 for v in rlcisr_values]
	print('Rx loopback activation codes detected:   [{:s}]'.format(','.join([str(n) for n in rxastats])))
	print('Rx loopback deactivation codes detected: [{:s}]'.format(','.join([str(n) for n in rxdstats])))

	rlcvc = span.rlcvc
	print('Rx line code violations: {:5d}'.format(rlcvc))

	rfaec = span.rfaec
	print('Rx framing alignment bit errors: {:5d}'.format(rfaec))

	rsefc = span.rsefc
	print('Rx severely-errored frames: {:3d}'.format(rsefc))

	rsbbec = span.rsbbec
	print('Rx CRC-6 bit errors: {:5d}'.format(rsbbec))

	rsc = span.rsc
	print('Rx slips: {:5d}'.format(rsc))

	rlfc = span.rlfc
	print('Rx loss of frame: {:5d}'.format(rlfc))

	rcfac = span.rcfac
	print('Rx change of frame alignment: {:5d}'.format(rcfac))

	pbec = span.pbec
	print('Rx PRBS bit errors: {:5d}'.format(pbec))

	tsc = span.tsc
	print('Tx slips: {:5d}'.format(tsc))

	ezvc = span.ezvc
	print('Rx excessive zero violations: {:5d}'.format(ezvc))

	lfcsec1 = span.lfcsec1
	print('LAPD 1 frame check sequence errors: {:5d}'.format(lfcsec1))

	lfcsec2 = span.lfcsec2
	print('LAPD 2 frame check sequence errors: {:5d}'.format(lfcsec2))

	lfcsec3 = span.lfcsec3
	print('LAPD 3 frame check sequence errors: {:5d}'.format(lfcsec3))

	line = []
	for channel in span.channels:
		rsar = channel.rsar
		status = ['-'] * 4
		if rsar & 1:
			status[3] = 'D'
		if rsar & 2:
			status[2] = 'C'
		if rsar & 4:
			status[1] = 'B'
		if rsar & 8:
			status[0] = 'A'
		line.append(''.join(status))
	print('RxSig: {:s}'.format(' '.join(line)))

def formatted_read_spans(device, fn_get, format):
	values = [fn_get(span) for span in device.spans]
	formatted = ' '.join([format.format(value) for value in values])
	return formatted

def action_status(device, args):
	if args.all:

		print('lock   \\                             frame', formatted_read_spans(device, lambda span: (span.rifr  >> 7) & 1, '{:5d}'))
		print('       \\                        multiframe', formatted_read_spans(device, lambda span: (span.sbisr >> 3) & 1, '{:5d}'))
		print()

		print('counts \\ rx \\         line code violations', formatted_read_spans(device, lambda span: span.rlcvc,  '{:5d}'))
		print('       |    | framing alignment bit errors', formatted_read_spans(device, lambda span: span.rfaec,  '{:5d}'))
		print('       |    |       severely-errord frames', formatted_read_spans(device, lambda span: span.rsefc,  '{:5d}'))
		print('       |    |             crc-6 bit errors', formatted_read_spans(device, lambda span: span.rsbbec, '{:5d}'))
		print('       |    |                        slips', formatted_read_spans(device, lambda span: span.rsc,    '{:5d}'))
		print('       |    |                loss of frame', formatted_read_spans(device, lambda span: span.rlfc,   '{:5d}'))
		print('       |    |    change of frame alignment', formatted_read_spans(device, lambda span: span.rcfac,  '{:5d}'))
		print('       |    \\    excessive zero violations', formatted_read_spans(device, lambda span: span.ezvc,   '{:5d}'))
		print('       |')
		print('       \\ tx \\                        slips', formatted_read_spans(device, lambda span: span.tsc,    '{:5d}'))

	# ciasr = span.ciasr
	# rxais_ci_state = (ciasr >> 5) & 1
	# rxrai_ci_state = (ciasr >> 4) & 1
	# print('Rx alarm indication signal - customer installation (AIS-CI): {:d}'.format(rxais_ci_state))
	# print('Rx remote alarm indication - customer installation (AIS-CI): {:d}'.format(rxrai_ci_state))

	# rlcisr_values = (span.rlcisr0, span.rlcisr1, span.rlcisr2, span.rlcisr3, span.rlcisr4, span.rlcisr5, span.rlcisr6, span.rlcisr7)
	# rxastats = [(v >> 3) & 1 for v in rlcisr_values]
	# rxdstats = [(v >> 2) & 1 for v in rlcisr_values]
	# print('Rx loopback activation codes detected:   [{:s}]'.format(','.join([str(n) for n in rxastats])))
	# print('Rx loopback deactivation codes detected: [{:s}]'.format(','.join([str(n) for n in rxdstats])))

	# pbec = span.pbec
	# print('Rx PRBS bit errors: {:5d}'.format(pbec))

	# lfcsec1 = span.lfcsec1
	# print('LAPD 1 frame check sequence errors: {:5d}'.format(lfcsec1))

	# lfcsec2 = span.lfcsec2
	# print('LAPD 2 frame check sequence errors: {:5d}'.format(lfcsec2))

	# lfcsec3 = span.lfcsec3
	# print('LAPD 3 frame check sequence errors: {:5d}'.format(lfcsec3))

	# line = []
	# for channel in span.channels:
	# 	rsar = channel.rsar
	# 	status = ['-'] * 4
	# 	if rsar & 1:
	# 		status[3] = 'D'
	# 	if rsar & 2:
	# 		status[2] = 'C'
	# 	if rsar & 4:
	# 		status[1] = 'B'
	# 	if rsar & 8:
	# 		status[0] = 'A'
	# 	line.append(''.join(status))
	# print('RxSig: {:s}'.format(' '.join(line)))

def action_test(device, args):
	span = device.spans[int(args.span)]

	channels = args.channel
	if channels is None:
		channels_range = range(len(span))
	elif channels < 0 or channels > 23:
		raise RuntimeError('Channel value out of range')
	else:
		channels_range = range(channels, channels)

	span = device.spans[span]
	# channel_0 = span_0.channels[0]

	line = ['{:1d}.{:02d} RSAR:'.format(span.index, channels_range.start)]
	for channel_index in channels_range:
		channel = span.channels[channel_index]
		rsar = channel.rsar
		line.append('{:02x}'.format(rsar))
	line = ' '.join(line)
	print(line)

import argparse
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

parser_dump = subparsers.add_parser('dump')
parser_dump.set_defaults(func=action_dump)

parser_read = subparsers.add_parser('read')
parser_read.add_argument("register", type=str, default=None)
parser_read.set_defaults(func=action_read)

parser_write = subparsers.add_parser('write')
parser_write.add_argument("register", type=str, default=None)
parser_write.add_argument("value", type=str, default=None)
parser_write.set_defaults(func=action_write)

# parser_defaults = subparsers.add_parser('defaults')
# parser_defaults.set_defaults(func=action_defaults)

parser_init = subparsers.add_parser('init')
parser_init.add_argument("--span", type=int, default=None)
parser_init.set_defaults(func=action_init)

parser_status = subparsers.add_parser('status')
parser_status.add_argument("--all", action='store_const', const=True)
parser_status.add_argument("--span", type=int, default=None)
parser_status.set_defaults(func=action_status)

parser_monitor = subparsers.add_parser('monitor')
parser_monitor.add_argument("--span", type=int, default=None)
# parser_monitor.add_argument("--channel", type=int, default=None)
parser_monitor.set_defaults(func=action_monitor)

parser_reset = subparsers.add_parser('reset')
parser_reset.set_defaults(func=action_reset)

parser_channel = subparsers.add_parser('channel')
parser_channel.add_argument("--span", type=int, default=None)
parser_channel.add_argument("--channel", type=int, default=None)
parser_channel.add_argument("--rbs", type=str, default=None)
parser_channel.add_argument("--pcm", type=str, default=None)
parser_channel.set_defaults(func=action_channel)


parser_test = subparsers.add_parser('test')
parser_test.add_argument("--span", type=int, default=None)
parser_test.add_argument("--channel", type=int, default=None)
parser_test.set_defaults(func=action_test)


args = parser.parse_args()

# device = usb.core.find(idVendor=VENDOR_ID, idProduct=PRODUCT_ID)
device = Device()
args.func(device, args)
